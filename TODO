* It looks like there's a race between threads
  on the spointsLock mutex when the process is being
  shut down: sometimes the process SIGSEGVs in the
  call to Tcl_MutexUnlock() in the syncpoints
  manager thread.

  The cause of this might be the fact mutex gets
  freed while the management thread's proc is running
  and has this mutex locked; then at unlock it
  accesses the freed memory.

  The mitigation is not yet clear.
  One possible solution is to count threads which loaded
  the package and explicitly shut the manager thread down
  when this count goes down to 0.
  The possibility for this solution is unclear:
  - Is it guaranteed that the finalization handler
    for our "master" thread runs earlier than for
    the manager thread?
    Don't they even run in parallel?

    This implies studying of whether the threads
    created using Tcl_CreateThread are registered
    somewhere and are forcibly cleaned up at exit;
    and if yes, it what order.
    If they do, and the order is unknown, it might
    turn out that resorting to direct creation
    of a pthread might help as such a thread
    will possibly not be cleaned up by Tcl
    so we will be able to reap it themselves.

  - It seems that Tcl has no exposed API for
    forcibly destroying threads: one can only
    quit the current thread.
    This means we have to somehow notify the
    manager thread that is should exit.
    But this requires waiting on that thread.
    So possibly the thread has to be joinable.
    On the other hand, we can make the manager
    thread condvar an enum, not flag; this will
    allow direct signaling that the thread should
    exit immediately after it was cond-notified.
    This will possibly eliminate the need of
    waiting for that thread to exit.

  NOTE it also might turn out that the manager thread
  fails to start before we signal a syncpoint.
  This seems to be possible because with debug
  syncpoints init/finalize printouts enabled
  (commit 7094070) we don't see any printouts from
  the sending/receiving code.
  Thus, the race between the manager thread and the
  threads which use the package (including main
  in the case of tests/rtsend.tcl) might as well
  occur even at startup.

* Investigate possibility to improve implementation
  of signal tables.
  Factoring out their handling to a common
  data structure looks interesting.

* Try to simplify the implementation of
  InfoCmd_Signum and InfoCmd_Name.

* Looks there's no more code that calls
  GetSignumByName and GetNameBySignum
  with interp != NULL.
  If so, their implementation should possibly
  be updated.

* Consider removal of GetSignumByName()
  and GetNameBySignum() from unix/sigtables.c
  as the code implementing signal objects
  now uses FindSignalBy*() functions.

* Provide for listing of POSIX real-time signals
  in the signals[] table.

  The problem is that a) the number of such signals
  is not fixed; b) their min and max numbers are
  not fixed.
  This imples we possibly have to make up a dynamic
  table of signals, or may be move directly to
  storing the "signal objects" instead of just pairs
  of signal name and number.

  Also it's not quite clear is it possible for
  SIGRTMIN to change at runtime or we're guaranteed
  that it stays the same over the lifetime of the
  process.

* Hash table lookup functions should mimic the behaviour
  of Tcl_GetIndexFromObj() and return a proper error
  message which includes all the allowed elements from
  the respective tables.

  NOTE: it might turn out that the generation of such
  a message should be left out for some other code,
  and unix/sigtables.c is just to provide
  GetListOfNames and GetListOfSignums.

* Implement changing signal disposition to
  SIG_DFL and SIG_IGN.

* Think about a robust way to keep signal dispositions
  and the table of syncpoints in sync.

* Think about saving the "subverted" signal handler
  (returned by sigaction() with non-empty last arg)
  and providing for a) calling of this handler;
  b) restoring it.
  This could be useful for interoperating with
  other signal-handling extensions or even with the core.

* GDB lists a whole lot of signals (via its "info signals"
  command) which signal(7) doesn't mention
  (on Debian Lenny).
  It worth studying whether inclusion of these signals
  is desired or not.

* Looks like our package fails to load after the
  Thread package is loaded while current dir
  appears to be unchanged.

  Indeed, it seems like a subtle problem with Tcl's [load]
  command, as its idea about the current directory
  might be different from that of the system, because after,
  say, the Thread package is loaded,
  [file exists libposixsignal0.1.so] returns 1
  but [load] on a non-qualified name fails, *and* it works
  for the full file name.

* Do we really need signal vector for initialization?
  Currently only creation of the table of event handlers
  could benefit from it, and the elements of the
  table of syncpoints are initially initialized to NULL.
  On the other hand, this might prove as being a more
  universal approach, especially if the table of syncpoints
  will change its format.

